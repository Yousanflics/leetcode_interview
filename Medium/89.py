# 关于 graycode 的一些性质
# 格雷码是一种相邻两项只有一位不同的二进制序列。例如，n = 2 时的格雷码：
# 00 → 0
# 01 → 1
# 11 → 3
# 10 → 2
# 对应的10进制序列为
# [0, 1, 3, 2]

# 为什么 res[-1] ^ (i & -i) 能生成格雷码？
# i & -i 总是返回 i 的最低位 1，它决定了本次翻转的二进制位。
# res[-1] ^ (i & -i) 保证了相邻两个数仅有 1 位不同，满足格雷码要求。
# 这个方法基于格雷码的递推公式：
# python
# 复制
# 编辑
# G(i) = i ⊕ (i >> 1)
# 但它巧妙地利用 i & -i 让代码更直观。
from typing import List
class Solution:
    def grayCode(self, n: int) -> List[int]:
        res = [0]
        # Step 1: 遍历 1 到 2^n - 1
        # 2^n 是 n 位格雷码的总长度，所以我们生成 2^n 个数字
        # i 表示当前生成的第 i 个格雷码
        for i in range(1, 2**n):
            res.append(res[-1]^(i&-i))
        return res

if __name__ == '__main__':
    s = Solution()
    res = s.grayCode(2)
    print(res)
    #for num in res:
        

# i	i (二进制)	-i (二进制)	i & -i (结果)	作用
# 1	0001	1111	0001 → 1	取最低位 1
# 2	0010	1110	0010 → 2	取最低位 1
# 3	0011	1101	0001 → 1	取最低位 1
# 4	0100	1100	0100 → 4	取最低位 1
# 5	0101	1011	0001 → 1	取最低位 1
# 6	0110	1010	0010 → 2	取最低位 1
# 7	0111	1001	0001 → 1	取最低位 1

# i  = 6
# i  = 6   # 0110 (二进制)
# -i = -6 # 1010 (二进制) (补码计算)
# i  & -i  # 0010 = 2

# 这里使用异或是保留都不相同的地方 0 和 1 相同的这些就不管了

