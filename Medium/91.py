耗时最短的 Solution

给定一个只包含数字的字符串 s，你可以将它按照 A-Z（1 → A, 2 → B, ..., 26 → Z）进行解码。计算有多少种不同的解码方式。
s = "226"

2 2 6 → "BBF"
22 6 → "VF"
2 26 → "BZ" 总共有 3 种解码方式，返回 3。


思路：

设 dp[i] 为以 s[i] 结尾的字符串的解码方式数：
    dp[i] = (s[i] > '0') * dp[i-1] + (10 <= int(s[i-1:i+1]) <= 26) * dp[i-2]
- (s[i] > '0') 确保 s[i] 不是 '0'，可以单独解码。
- (10 ≤ int(s[i-1:i+1]) ≤ 26) 确保 s[i-1:i+1]（当前字符 d 和前一个字符 p 组合成的两位数）在 10-26 之间，可以作为一个整体解码。


class Solution:
    def numDecodiings(self, s: str) -> int:
        # v：dp[i-2]，表示 前两位的解码方式，初始为 0（因为 i-2 可能不存在）。
        # w：dp[i-1]，表示 前一位的解码方式，如果 s 不是空字符串，则 dp[0]=1，否则 0。
        # p：s[i-1]，表示 前一个字符，初始为空字符 '',这个时候没有字符参与 dp 的过程。
        v, w, p = 0, int(s>''), ''
        for d in s:
            # v = w 是因为 d[i-1] 现在变成了 d[i - 2]所以之前的w给到现在的 v
            # w = (d > '0') * w + (9 < int(p + d) < 27) * v
            # (d > '0') * w：
                # 如果 d != '0'，表示当前字符 d 可以单独解码，所以 w 贡献上一轮的 w。
                # 否则 d == '0'，w = 0（因为 0 不能单独解码）。
            # (9 < int(p + d) < 27) * v：
                # 如果 p+d 形成的两位数 int(p+d) 在 [10, 26] 之间，则 w 还可以加上 v，即 dp[i-2] 的贡献。
            v, w, p = w, (d>'0')*w + (9<int(p+d)<27)*v, d
        #最后返回的还是 w，最关键的这个
        return w
